#include "pch.h"
#include "lpp.h"    // header file generated by MIDL compiler
#include "rpc_server.h"
#include <vector>
#include <NtDsAPI.h>
#include <LM.h>
#include <security.h>
#include "eventlog.h"
#include <memory>
#include "../PasswordFilter/messages.h"

extern "C" __declspec(dllimport) int __stdcall PasswordFilterEx(
	LPCWSTR AccountName,
	LPCWSTR FullName,
	LPCWSTR Password,
	BOOLEAN SetOperation);

RPC_STATUS __stdcall rpc_server::RpcServerIfCallback(IN void *ifx, IN void *context)
{
	ULONG authn_level;
	ULONG authn_service;
	RPC_AUTHZ_HANDLE privs;

	if (RpcBindingInqAuthClient(context, &privs, NULL, &authn_level, &authn_service, NULL) != RPC_S_OK)
	{
		return RPC_S_ACCESS_DENIED;
	}

	if (authn_level != RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
	{
		wprintf_s(L"The client connection is not encrypted\n");
		return RPC_S_ACCESS_DENIED;
	}

	if (authn_service != RPC_C_AUTHN_GSS_KERBEROS)
	{
		wprintf_s(L"The client connection was not authenticated with kerberos\n");
		return RPC_S_ACCESS_DENIED;
	}

	wprintf_s(L"Client connection is secure\n");
	return RPC_S_OK;
};

int GetPasswordFilterResult(handle_t handle, const wchar_t *username, const wchar_t *fullname, const wchar_t *password, const boolean isSetOperation)
{
	wprintf_s(L"Checking password for user: %s, full name: %s\n", username, fullname);

	const int result = PasswordFilterEx(username, fullname, password, isSetOperation);

	wprintf_s(L"Password filter returned %d\n", result);

	SecureZeroMemory(PVOID(password), wcslen(password) * sizeof(wchar_t));

	return result;
}

//
//void rpc_server::MakeSpn() const
//{
//	DWORD status = ERROR_SUCCESS;
//	ULONG spn_array_count = 0;
//	LPWSTR* spn_array = NULL;
//	HANDLE hDS = 0;
//	PDOMAIN_CONTROLLER_INFO dc_info;
//	ULONG dn_size = 0;
//
//	try {
//		status = DsGetSpn(DS_SPN_DNS_HOST,
//			L"lpp",
//			NULL, // DN of this service.
//			0, // Use the default instance port.
//			0, // Number of additional instance names.
//			NULL, // No additional instance names.
//			NULL, // No additional instance ports.
//			&spn_array_count, // Size of SPN array.
//			&spn_array); // Returned SPN(s).	
//
//		if (status != ERROR_SUCCESS)
//		{
//			throw std::system_error(status, std::system_category(), "DsGetSpn failed");
//		}
//
//		status = DsGetDcName(NULL, NULL, NULL, NULL, DS_RETURN_DNS_NAME, &dc_info);
//
//		if (status != NO_ERROR)
//		{
//			throw std::system_error(status, std::system_category(), "DsGetDcName failed");
//		}
//
//		status = DsBind(NULL, dc_info->DomainName, &hDS);
//
//		if (status != ERROR_SUCCESS)
//		{
//			throw std::system_error(status, std::system_category(), "DsBind failed");
//		}
//
//		status = NetApiBufferFree(dc_info);
//
//		if (status != NERR_Success)
//		{
//			throw std::system_error(status, std::system_category(), "NetApiBufferFree failed");
//		}
//
//		status = GetComputerObjectName(NameFullyQualifiedDN, NULL, &dn_size);
//
//		if (dn_size <= 0)
//		{
//			throw std::system_error(status, std::system_category(), "Failed to get DN length from GetComputerObjectName");
//		}
//
//		auto computerDN = std::make_unique<wchar_t[]>(dn_size);
//
//		if (!GetComputerObjectName(NameFullyQualifiedDN, computerDN.get(), &dn_size))
//		{
//			throw std::system_error(status, std::system_category(), "Failed to get DN from GetComputerObjectName");
//		}
//
//		status = DsWriteAccountSpn(hDS, DS_SPN_ADD_SPN_OP, computerDN.get(), spn_array_count, const_cast<LPCWSTR*>(spn_array));
//
//		if (status != NO_ERROR)
//		{
//			throw std::system_error(status, std::system_category(), "DsWriteAccountSpn failed");
//		}
//	}
//	catch (...)
//	{
//		if (hDS)
//		{
//			DsUnBind(&hDS);
//		}
//
//		if (spn_array_count)
//		{
//			DsFreeSpnArray(spn_array_count, spn_array);
//		}
//
//		throw;
//	}
//}

std::wstring rpc_server::GenerateSpn()
{
	DWORD status = ERROR_SUCCESS;
	ULONG spn_array_count = 0;
	LPWSTR* spn_array = NULL;
	std::wstring spn;

	status = DsGetSpn(DS_SPN_DNS_HOST, L"lpp", NULL, 0, 0, NULL, NULL, &spn_array_count, &spn_array);

	if (status != ERROR_SUCCESS)
	{
		throw std::system_error(status, std::system_category(), "DsGetSpn failed");
	}

	if (spn_array_count)
	{
		spn = spn_array[0];

		DsFreeSpnArray(spn_array_count, spn_array);
	}

	return spn;
}

void rpc_server::TryRegisterSpn(const std::wstring& serviceClass)
{
	try
	{
		RegisterSpn(serviceClass);
	}
	catch (std::system_error const& e)
	{
		eventlog::getInstance().log(EVENTLOG_ERROR_TYPE, MSG_SPN_REGISTRATION_FAILURE, 2, std::to_string(e.code().value()).c_str(), e.what());
	}
}

void rpc_server::RegisterSpn(const std::wstring& serviceClass)
{
	DWORD status = DsServerRegisterSpn(DS_SPN_ADD_SPN_OP, serviceClass.c_str(), NULL);

	if (status != ERROR_SUCCESS)
	{
		throw std::system_error(status, std::system_category(), "DsServerRegisterSpn failed");
	}
}

void rpc_server::InitializeRpcServer()
{
	std::vector<std::wstring> protocols = { L"ncacn_ip_tcp" };
	const LPCWSTR annotation = L"Lithnet Password Protection";
	RPC_BINDING_VECTOR* pbindingVector = 0;
	RPC_STATUS status;

	try
	{
		TryRegisterSpn(L"lpp");

		for (auto &var : protocols)
		{
			status = RpcServerUseProtseq(RPC_WSTR(var.c_str()), RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 0);

			if (status != RPC_S_OK)
			{
				throw std::system_error(status, std::system_category(), "RpcServerUseProtseq failed");
			}
		}

		status = RpcServerRegisterIfEx(passwordfilter_v1_0_s_ifspec, NULL, NULL, RPC_IF_ALLOW_SECURE_ONLY, RPC_C_LISTEN_MAX_CALLS_DEFAULT, &RpcServerIfCallback);

		if (status != RPC_S_OK)
		{
			throw std::system_error(status, std::system_category(), "RpcServerRegisterIfEx failed");
		}

		status = RpcServerInqBindings(&pbindingVector);

		if (status != RPC_S_OK)
		{
			throw std::system_error(status, std::system_category(), "RpcServerInqBindings failed");
		}

		status = RpcEpRegister(passwordfilter_v1_0_s_ifspec, pbindingVector, 0, RPC_WSTR(annotation));

		if (status != RPC_S_OK)
		{
			throw std::system_error(status, std::system_category(), "RpcEpRegister failed");
		}

		std::wstring spn = GenerateSpn();

		status = RpcServerRegisterAuthInfo(RPC_WSTR(spn.c_str()), RPC_C_AUTHN_GSS_KERBEROS, NULL, NULL);

		if (status != RPC_S_OK)
		{
			throw std::system_error(status, std::system_category(), "RpcServerRegisterAuthInfo failed");
		}

		initialized = true;
	}
	catch (...)
	{
		if (pbindingVector)
		{
			RpcBindingVectorFree(&pbindingVector);
		}

		throw;
	}

	if (pbindingVector)
	{
		RpcBindingVectorFree(&pbindingVector);
	}
}

void rpc_server::Start(bool wait) const
{
	if (!initialized)
	{
		throw std::exception("The client has not been initialized");
	}

	const unsigned int cMinCalls = 1;
	if (!wait)
	{
		wprintf_s(L"Endpoint listener starting\n");
	}
	else
	{
		wprintf_s(L"Endpoint listener starting and waiting for exit event\n");
	}

	const RPC_STATUS status = RpcServerListen(cMinCalls, RPC_C_PROTSEQ_MAX_REQS_DEFAULT, !wait);

	if (status != RPC_S_OK)
	{
		throw std::system_error(status, std::system_category(), "RpcServerListen failed");
	}

	if (!wait)
	{
		wprintf_s(L"Endpoint listener started\n");
	}
}

void rpc_server::WaitForEnd() const
{
	if (!initialized)
	{
		throw std::exception("The client has not been initialized");
	}

	const RPC_STATUS status = RpcMgmtWaitServerListen();

	if (status != RPC_S_OK)
	{
		throw std::system_error(status, std::system_category(), "RpcMgmtWaitServerListen failed");
	}

	wprintf_s(L"Endpoint listener stopped\n");
}

void rpc_server::Stop() const
{
	if (!initialized)
	{
		return;
	}

	RPC_BINDING_VECTOR* pbindingVector;

	const RPC_STATUS status = RpcServerInqBindings(&pbindingVector);

	if (status == RPC_S_OK && pbindingVector)
	{
		RpcEpUnregister(passwordfilter_v1_0_s_ifspec, pbindingVector, NULL);
		RpcBindingVectorFree(&pbindingVector);
	}

	RpcMgmtStopServerListening(NULL);
	RpcServerUnregisterIf(passwordfilter_v1_0_s_ifspec, NULL, FALSE);
}