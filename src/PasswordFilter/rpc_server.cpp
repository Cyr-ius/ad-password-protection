#include "stdafx.h"
#include <cstdio>
#include "lpp.h"    // header file generated by MIDL compiler
#include <system_error>
#include "rpc_server.h"
#include <vector>
#include <Windows.h>
#include <NtDsAPI.h>
#include <DsGetDC.h>
#include <LM.h>
#include <security.h>
#include <secext.h>
#include <system_error>
#include <memory>
#include "filter.h"

RPC_STATUS __stdcall RpcServerIfCallback(IN void *ifx, IN void *context)
{
	ULONG authn_level;
	ULONG authn_service;

	if (RpcBindingInqAuthClient(context, NULL, NULL, &authn_level, &authn_service, NULL) != RPC_S_OK)
	{
		return RPC_S_ACCESS_DENIED;
	}

	if (authn_level != RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
	{
		wprintf_s(L"The client connection is not encrypted\n");
		return RPC_S_ACCESS_DENIED;
	}

	if (authn_service != RPC_C_AUTHN_GSS_KERBEROS)
	{
		wprintf_s(L"The client connection was not authenticated with kerberos\n");
		return RPC_S_ACCESS_DENIED;
	}

	wprintf_s(L"Client connection is secure\n");
	return RPC_S_OK;
};

int GetPasswordFilterResult(handle_t handle, const wchar_t *username, const wchar_t *fullname, const wchar_t *password)
{
	wprintf_s(L"Checking password for user: %s, full name: %s\n", username, fullname);

	const int result = PasswordFilterEx(username, fullname, password, false);

	wprintf_s(L"Password filter returned %d\n", result);

	SecureZeroMemory(PVOID(password), wcslen(password) * sizeof(wchar_t));

	return result;
}

void rpc_server::MakeSpn() const
{
	DWORD status = ERROR_SUCCESS;
	ULONG spn_array_count = 0;
	LPWSTR* spn_array = NULL;
	HANDLE hDS = 0;
	PDOMAIN_CONTROLLER_INFO dc_info;
	ULONG dn_size = 0;

	try {
		status = DsGetSpn(DS_SPN_DNS_HOST,
			L"lpp",
			NULL, // DN of this service.
			0, // Use the default instance port.
			0, // Number of additional instance names.
			NULL, // No additional instance names.
			NULL, // No additional instance ports.
			&spn_array_count, // Size of SPN array.
			&spn_array); // Returned SPN(s).	

		if (status != ERROR_SUCCESS)
		{
			throw std::system_error(status, std::system_category(), "DsGetSpn failed");
		}

		status = DsGetDcName(NULL, NULL, NULL, NULL, DS_RETURN_DNS_NAME, &dc_info);

		if (status != NO_ERROR)
		{
			throw std::system_error(status, std::system_category(), "DsGetDcName failed");
		}

		status = DsBind(NULL, dc_info->DomainName, &hDS);

		if (status != ERROR_SUCCESS)
		{
			throw std::system_error(status, std::system_category(), "DsBind failed");
		}

		status = NetApiBufferFree(dc_info);

		if (status != NERR_Success)
		{
			throw std::system_error(status, std::system_category(), "NetApiBufferFree failed");
		}

		status = GetComputerObjectName(NameFullyQualifiedDN, NULL, &dn_size);

		if (dn_size <= 0)
		{
			throw std::system_error(status, std::system_category(), "Failed to get DN length from GetComputerObjectName");
		}

		auto computerDN = std::make_unique<wchar_t[]>(dn_size);

		if (!GetComputerObjectName(NameFullyQualifiedDN, computerDN.get(), &dn_size))
		{
			throw std::system_error(status, std::system_category(), "Failed to get DN from GetComputerObjectName");
		}

		status = DsWriteAccountSpn(hDS, DS_SPN_ADD_SPN_OP, computerDN.get(), spn_array_count, const_cast<LPCWSTR*>(spn_array));

		if (status != NO_ERROR)
		{
			throw std::system_error(status, std::system_category(), "DsWriteAccountSpn failed");
		}
	}
	catch (...)
	{
		if (hDS)
		{
			DsUnBind(&hDS);
		}

		if (spn_array_count)
		{
			DsFreeSpnArray(spn_array_count, spn_array);
		}

		throw;
	}
}

void rpc_server::InitializeRpcServer()
{
	std::vector<std::wstring> protocols = { L"ncacn_ip_tcp" , L"ncalrpc" };
	const LPCWSTR annotation = L"Lithnet Password Protection";
	const LPCWSTR pszSpn = L"mgr-rnewing@fim-dev1.local";
	RPC_BINDING_VECTOR* pbindingVector = 0;
	RPC_STATUS status;

	MakeSpn();

	try
	{
		for (auto &var : protocols)
		{
			status = RpcServerUseProtseq(RPC_WSTR(var.c_str()), RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 0);

			if (status != RPC_S_OK)
			{
				throw std::system_error(status, std::system_category(), "RpcServerUseProtseq failed");
			}
		}

		status = RpcServerRegisterIfEx(passwordfilter_v1_0_s_ifspec, NULL, NULL, RPC_IF_ALLOW_SECURE_ONLY, RPC_C_LISTEN_MAX_CALLS_DEFAULT, &RpcServerIfCallback);

		if (status != RPC_S_OK)
		{
			throw std::system_error(status, std::system_category(), "RpcServerRegisterIfEx failed");
		}

		status = RpcServerInqBindings(&pbindingVector);

		if (status != RPC_S_OK)
		{
			throw std::system_error(status, std::system_category(), "RpcServerInqBindings failed");
		}

		status = RpcEpRegister(passwordfilter_v1_0_s_ifspec, pbindingVector, 0, RPC_WSTR(annotation));

		if (status != RPC_S_OK)
		{
			throw std::system_error(status, std::system_category(), "RpcEpRegister failed");
		}

		status = RpcServerRegisterAuthInfo(RPC_WSTR(pszSpn), RPC_C_AUTHN_GSS_KERBEROS, NULL, NULL);

		if (status != RPC_S_OK)
		{
			throw std::system_error(status, std::system_category(), "RpcServerRegisterAuthInfo failed");
		}

		wprintf_s(L"Endpoint registered\n");

		initialized = true;
	}
	catch (...)
	{
		if (pbindingVector)
		{
			RpcBindingVectorFree(&pbindingVector);
		}

		throw;
	}

	if (pbindingVector)
	{
		RpcBindingVectorFree(&pbindingVector);
	}
}

void rpc_server::Start(bool wait) const
{
	if (!initialized)
	{
		throw std::exception("The client has not been initialized");
	}

	const unsigned int cMinCalls = 1;
	if (!wait)
	{
		wprintf_s(L"Endpoint listener starting\n");
	}
	else
	{
		wprintf_s(L"Endpoint listener starting and waiting for exit event\n");
	}

	const RPC_STATUS status = RpcServerListen(cMinCalls, RPC_C_PROTSEQ_MAX_REQS_DEFAULT, !wait);

	if (status != RPC_S_OK)
	{
		throw std::system_error(status, std::system_category(), "RpcServerRegisterAuthInfo failed");
	}

	if (!wait)
	{
		wprintf_s(L"Endpoint listener started\n");
	}
}

void rpc_server::WaitForEnd() const
{
	if (!initialized)
	{
		throw std::exception("The client has not been initialized");
	}

	const RPC_STATUS status = RpcMgmtWaitServerListen();

	if (status != RPC_S_OK)
	{
		throw std::system_error(status, std::system_category(), "RpcServerRegisterAuthInfo failed");
	}

	wprintf_s(L"Endpoint listener stopped\n");
}

void rpc_server::Stop() const
{
	if (!initialized)
	{
		return;
	}

	RPC_BINDING_VECTOR* pbindingVector;

	RPC_STATUS status = RpcServerInqBindings(&pbindingVector);

	if (status == RPC_S_OK && pbindingVector)
	{
		status = RpcEpUnregister(passwordfilter_v1_0_s_ifspec, pbindingVector, NULL);
		RpcBindingVectorFree(&pbindingVector);
	}

	RpcMgmtStopServerListening(NULL);
	RpcServerUnregisterIf(passwordfilter_v1_0_s_ifspec, NULL, FALSE);
}